{
  "name": "sink_q",
  "version": "0.0.7",
  "description": "Queue for holding events until they're ready to be fired",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git@githubcom:technicalmachine/sink_q.git"
  },
  "author": {
    "name": "Nathan Lintz"
  },
  "license": "MIT",
  "readme": "#sink_q.js\n###Intro\nThis library is used for queuing async functions and flushing the queue when an on ready function is called. For example, if you need to run configuration code before a function can be called, its best to wrap the functions that need configuration in a call to queue.push and call queue.ready when the 'ready' event is emitted. This way, the configuration code will run first and the queue will be flushed automatically when 'ready' fires.\n\nUse this library if you need to run multiple async commands in series and want to store the async calls until after configration code has executed. The queue works by calling each asynchronous after the previous asynchronous function's callback is called.\n\n###How to Use\nRequire the sink_q library\n\n```js\nvar Queue = require(sink_q);\n```\n\nCall l√© constructor\n\n```js\nvar myQueue = new Queue();\n```\n\n\nThe two public methods are \"push\" and \"ready\". Push will push events onto the queue and will fire them as soon as \nthe queue is ready.\n```js\nmyQueue.ready(); // Call this when you're ready to rock\n```\n\nThere are two ways to call push. If you dont need to execute a callback, simply do\n```js\nmyQueue.push(function () {\n  async stuff sans callback\n});\n```\n\nIf the function has a callback instead run \n```js\nmyQueue.push(function (callback) {\n  async stuff with callback\n}, callback)\n```\n\nIf you push a function onto the queue whose callback pushes a function onto the queue you'll run into a deadlock. This happens because the outer function's callback won't be called until the queue unlocks and the queue remains locked until the inner function (AKA the outer function's callback) is called. This is confusing so hopefully an example will explain it.\n```js\nmyQueue.push(function (callback) {\n  myQueue.push(function () {\n    async stuff\n  })\n}, callback)\n\n```\n\nThe solution to the deadlock is setting the setImmeadiate flag to true when you push a function which pushes a function onto the queue.\n```js\nmyQueue.push(function (callback) {\n  myQueue.push(function () {\n    async stuff\n    callback();\n  })\n}, callback, true)\n```\n\nNotice that to resolve the deadlock we use\n```js\nmyQueue.push(function (callback) {}, callback, true)\n```\n\ninstead of \n\n```js\nmyQueue.push(function (callback) {}, callback)\n```",
  "readmeFilename": "readme.md",
  "_id": "sink_q@0.0.7",
  "dist": {
    "shasum": "c9995ef58a13044981e4e3a24de96c172fa97134"
  },
  "_from": "sink_q@*",
  "_resolved": "https://registry.npmjs.org/sink_q/-/sink_q-0.0.7.tgz"
}
